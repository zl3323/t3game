<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T3 Battle - Fighting Arena</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&family=VT323&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-red: #ff0044;
            --primary-blue: #0088ff;
            --primary-yellow: #ffcc00;
            --dark-bg: #0a0e27;
            --light-bg: #1a1e37;
            --gold: #ffcc00;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
            --success: #00ff88;
            --danger: #ff3366;
            --text-light: #ffffff;
            --text-dim: #8899aa;
            --ps-blue: #0054a6;
            --ghost-hp: rgba(255, 255, 255, 0.3);
        }
        
        body {
            font-family: 'VT323', monospace;
            background: #000;
            min-height: 100vh;
            color: var(--text-light);
            overflow-x: hidden;
            position: relative;
        }
        
        /* Cover Screen */
        .cover-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
        }
        
        .cover-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .cover-image {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            filter: brightness(0.9);
        }
        
        .cover-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, 
                rgba(0, 0, 0, 0) 0%, 
                rgba(0, 0, 0, 0.3) 50%, 
                rgba(0, 0, 0, 0.7) 100%);
        }
        
        .cover-content {
            position: relative;
            z-index: 10;
            text-align: center;
            animation: coverFloat 3s ease-in-out infinite;
        }
        
        @keyframes coverFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .game-logo {
            font-family: 'Press Start 2P', cursive;
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 
                3px 3px 0 #000,
                -3px -3px 0 #000,
                3px -3px 0 #000,
                -3px 3px 0 #000,
                0 0 20px var(--primary-yellow),
                0 0 40px var(--primary-yellow);
            letter-spacing: 4px;
            animation: logoGlow 2s ease-in-out infinite;
        }
        
        .game-logo .t3 {
            color: var(--primary-yellow);
            display: inline-block;
            animation: t3Pulse 1s ease-in-out infinite;
        }
        
        .game-logo .battle {
            color: var(--text-light);
            display: inline-block;
        }
        
        @keyframes logoGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        @keyframes t3Pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .start-button {
            margin-top: 50px;
            padding: 20px 60px;
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-yellow), var(--primary-red));
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 10px 30px rgba(255, 204, 0, 0.3),
                0 0 0 3px rgba(255, 255, 255, 0.1);
            animation: startBtnPulse 2s ease-in-out infinite;
        }
        
        @keyframes startBtnPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 10px 30px rgba(255, 204, 0, 0.3),
                    0 0 0 3px rgba(255, 255, 255, 0.1);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 
                    0 15px 40px rgba(255, 204, 0, 0.5),
                    0 0 0 5px rgba(255, 255, 255, 0.2);
            }
        }
        
        .start-button:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 
                0 20px 50px rgba(255, 204, 0, 0.6),
                0 0 0 5px rgba(255, 255, 255, 0.3);
        }
        
        .press-start-text {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: rgba(255, 255, 255, 0.8);
            animation: blink 1s step-start infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            50.01%, 100% { opacity: 0; }
        }
        
        /* Main Game Container */
        .game-container {
            display: none;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1e37 50%, #0a0e27 100%);
            position: relative;
        }
        
        .game-container.active {
            display: block;
        }
        
        /* Background Effects */
        .game-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.03) 2px,
                    rgba(255, 255, 255, 0.03) 4px
                );
            pointer-events: none;
            z-index: 1;
        }
        
        .container {
            position: relative;
            z-index: 2;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Game Header */
        .game-header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.1), rgba(255, 0, 68, 0.1));
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 42px;
            background: linear-gradient(45deg, var(--primary-yellow), var(--primary-red));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
            margin-bottom: 10px;
        }
        
        .game-subtitle {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            color: var(--text-dim);
            letter-spacing: 4px;
        }
        
        /* Screen Containers */
        .screen {
            display: none;
            animation: screenFadeIn 0.5s ease-out;
        }
        
        .screen.active {
            display: block;
        }
        
        @keyframes screenFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(20px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
            }
        }

        /* Mode Selection Screen */
        .mode-screen {
            text-align: center;
            padding: 60px 20px;
        }

        .mode-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            color: var(--gold);
            margin-bottom: 60px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
            animation: titleFloat 2s ease-in-out infinite;
        }

        @keyframes titleFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .mode-buttons {
            display: flex;
            justify-content: center;
            gap: 60px;
            flex-wrap: wrap;
        }

        .mode-button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            padding: 40px 60px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .mode-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 204, 0, 0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .mode-button:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--gold);
            box-shadow: 0 20px 40px rgba(255, 204, 0, 0.4);
        }

        .mode-button:hover::before {
            opacity: 1;
        }

        .mode-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .mode-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: var(--gold);
            margin-bottom: 10px;
        }

        .mode-desc {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--text-dim);
        }
        
        /* Character Selection */
        .character-selection-container {
            margin-top: 40px;
        }
        
        .selection-title {
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 32px;
            color: var(--gold);
            margin-bottom: 40px;
            animation: titleFloat 2s ease-in-out infinite;
        }

        .player-turn-indicator {
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.2), rgba(255, 0, 68, 0.2));
            border-radius: 20px;
            border: 2px solid var(--gold);
        }

        .player-turn-indicator.player1 {
            color: var(--primary-yellow);
            text-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
        }

        .player-turn-indicator.player2 {
            color: var(--primary-blue);
            text-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
        }
        
        .character-showcase {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border-radius: 30px;
            padding: 40px;
            border: 2px solid rgba(255, 204, 0, 0.3);
            box-shadow: 0 0 50px rgba(255, 204, 0, 0.1);
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .character-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .character-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 204, 0, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
            transform: rotate(45deg);
        }
        
        .character-card:hover:not(.disabled) {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--gold);
            box-shadow: 
                0 20px 40px rgba(255, 204, 0, 0.3),
                inset 0 0 20px rgba(255, 204, 0, 0.1);
        }
        
        .character-card:hover:not(.disabled)::before {
            opacity: 1;
        }
        
        .character-card.selected {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.5),
                inset 0 0 20px rgba(0, 255, 136, 0.2);
            animation: selectedPulse 1s ease-in-out infinite;
        }

        .character-card.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: scale(0.95);
        }

        .character-card.disabled:hover {
            transform: scale(0.95);
        }
        
        @keyframes selectedPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 30px rgba(0, 255, 136, 0.5),
                    inset 0 0 20px rgba(0, 255, 136, 0.2);
            }
            50% { 
                box-shadow: 
                    0 0 50px rgba(0, 255, 136, 0.7),
                    inset 0 0 30px rgba(0, 255, 136, 0.3);
            }
        }
        
        .character-avatar {
            width: 100px;
            height: 100px;
            margin: 0 auto 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .character-avatar img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
            transition: transform 0.3s ease;
        }
        
        .character-card:hover:not(.disabled) .character-avatar img {
            transform: scale(1.1);
        }
        
        .character-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            text-align: center;
            margin-bottom: 15px;
            color: var(--gold);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }
        
        .character-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-name {
            font-size: 18px;
            color: var(--text-dim);
            font-weight: bold;
        }
        
        .stat-bar {
            width: 80px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: statShine 3s ease-in-out infinite;
        }
        
        @keyframes statShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .stat-fill.health {
            background: linear-gradient(90deg, #00ff88, #00cc66);
        }
        
        .stat-fill.attack {
            background: linear-gradient(90deg, #ff3366, #ff0044);
        }
        
        .stat-fill.defense {
            background: linear-gradient(90deg, #0088ff, #0066cc);
        }
        
        /* Battle Screen */
        .battle-container {
            margin-top: 0;
        }

        /* Battle HUD */
        .battle-hud {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            border-bottom: 3px solid rgba(255, 204, 0, 0.3);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            backdrop-filter: blur(10px);
        }

        .hud-player {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .hud-player.p2 {
            flex-direction: row-reverse;
        }

        .hud-avatar {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--gold);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hud-avatar img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .hud-info {
            flex: 1;
        }

        .hud-info.p2 {
            text-align: right;
        }

        .hud-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .hud-player.p1 .hud-name {
            color: var(--primary-yellow);
        }

        .hud-player.p2 .hud-name {
            color: var(--primary-blue);
        }

        .hud-hp-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .hud-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 2;
        }

        .hud-hp-ghost {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--ghost-hp);
            transition: width 1s ease-out;
            transition-delay: 0.2s;
            z-index: 1;
        }

        .hud-hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: white;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.7);
            z-index: 3;
        }

        .hud-center {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .round-indicator {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: var(--gold);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
            margin-bottom: 5px;
        }

        .hud-timer {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            color: white;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }

        .hud-timer.warning {
            color: var(--danger);
            animation: timerPulse 0.5s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .battle-arena {
            background: linear-gradient(135deg, 
                rgba(255, 0, 68, 0.1), 
                rgba(0, 136, 255, 0.1),
                rgba(255, 204, 0, 0.1));
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            padding: 40px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 50px rgba(255, 204, 0, 0.2),
                inset 0 0 50px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }
        
        .battle-field {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 40px;
            gap: 40px;
        }
        
        .fighter {
            flex: 1;
            text-align: center;
            position: relative;
        }
        
        .fighter-avatar {
            width: 180px;
            height: 180px;
            margin: 0 auto 20px;
            position: relative;
            animation: fighterBounce 2s ease-in-out infinite;
        }
        
        @keyframes fighterBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .fighter-avatar img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5));
        }
        
        .fighter-avatar.attacking {
            animation: attackAnimation 0.5s ease-out;
        }
        
        @keyframes attackAnimation {
            0% { transform: translateX(0) scale(1); }
            25% { transform: translateX(50px) scale(1.1); }
            50% { transform: translateX(40px) scale(1.05); }
            100% { transform: translateX(0) scale(1); }
        }
        
        .fighter-avatar.damaged {
            animation: damageAnimation 0.5s ease-out;
        }
        
        @keyframes damageAnimation {
            0%, 100% { 
                filter: brightness(1) drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5)); 
            }
            25%, 75% { 
                filter: brightness(2) saturate(0) drop-shadow(0 10px 30px rgba(255, 0, 0, 0.8)); 
            }
            50% { 
                filter: brightness(0.5) saturate(0) drop-shadow(0 10px 30px rgba(255, 0, 0, 1)); 
            }
        }
        
        .fighter-info {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            border-radius: 20px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .fighter-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }
        
        .fighter.player1 .fighter-name {
            color: var(--primary-yellow);
        }
        
        .fighter.player2 .fighter-name {
            color: var(--primary-blue);
        }
        
        .combo-indicator {
            font-size: 20px;
            color: var(--gold);
            margin-top: 10px;
            min-height: 30px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .combo-indicator.active {
            animation: comboFlash 0.5s ease-out;
        }
        
        @keyframes comboFlash {
            0% { 
                transform: scale(1); 
                text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            }
            50% { 
                transform: scale(1.2); 
                text-shadow: 0 0 20px rgba(255, 204, 0, 1);
            }
            100% { 
                transform: scale(1);
                text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            }
        }
        
        /* Question Area */
        .question-area {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 35px;
            margin-bottom: 30px;
            position: relative;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.3),
                inset 0 0 30px rgba(255, 204, 0, 0.05);
        }
        
        .turn-indicator {
            text-align: center;
            margin-bottom: 25px;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: var(--gold);
            animation: pulse 1s ease-in-out infinite;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            }
            50% { 
                opacity: 0.6;
                text-shadow: 0 0 20px rgba(255, 204, 0, 0.8);
            }
        }
        
        .question-text {
            font-size: 32px;
            text-align: center;
            margin-bottom: 35px;
            line-height: 1.5;
            color: var(--text-light);
            font-weight: bold;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
        }
        
        .answer-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .answer-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            padding: 25px;
            font-size: 24px;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'VT323', monospace;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.3);
        }
        
        .answer-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255, 204, 0, 0.4) 0%, transparent 70%);
            transition: width 0.3s, height 0.3s;
            transform: translate(-50%, -50%);
        }
        
        .answer-btn:hover {
            transform: translateY(-5px) scale(1.03);
            border-color: var(--gold);
            box-shadow: 
                0 15px 40px rgba(255, 204, 0, 0.3),
                inset 0 0 20px rgba(255, 204, 0, 0.1);
        }
        
        .answer-btn:hover::before {
            width: 400px;
            height: 400px;
        }
        
        .answer-btn.correct {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 136, 0.2));
            border-color: var(--success);
            animation: correctPulse 0.6s ease-out;
        }
        
        @keyframes correctPulse {
            0% { transform: scale(1); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .answer-btn.wrong {
            background: linear-gradient(135deg, rgba(255, 51, 102, 0.4), rgba(255, 51, 102, 0.2));
            border-color: var(--danger);
            animation: wrongShake 0.5s ease-out;
        }
        
        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }
        
        .answer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Game Result */
        .result-screen {
            text-align: center;
            padding: 50px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 204, 0, 0.5);
            border-radius: 30px;
            margin-top: 40px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 80px rgba(255, 204, 0, 0.3),
                inset 0 0 50px rgba(255, 204, 0, 0.1);
        }
        
        .result-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 204, 0, 0.15) 0%, transparent 50%);
            animation: resultGlow 4s linear infinite;
        }
        
        @keyframes resultGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .winner-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 56px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, var(--gold), var(--primary-yellow), var(--primary-red));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: winnerPulse 1s ease-in-out infinite;
            position: relative;
            z-index: 1;
            text-shadow: 0 0 30px rgba(255, 204, 0, 0.5);
        }
        
        @keyframes winnerPulse {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.08);
                filter: brightness(1.2);
            }
        }
        
        .winner-name {
            font-size: 42px;
            color: var(--gold);
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.3);
        }
        
        .final-stats {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
        }
        
        .final-stat {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px 30px;
            border-radius: 20px;
            border: 2px solid rgba(255, 204, 0, 0.3);
        }
        
        .final-stat-label {
            font-size: 20px;
            color: var(--text-dim);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .final-stat-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            color: var(--gold);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }
        
        /* Buttons */
        .btn {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            padding: 18px 40px;
            background: linear-gradient(135deg, var(--primary-yellow), var(--primary-red));
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 10px 30px rgba(255, 0, 68, 0.3),
                0 0 0 2px rgba(255, 255, 255, 0.1);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 15px 40px rgba(255, 0, 68, 0.5),
                0 0 0 3px rgba(255, 255, 255, 0.2);
        }
        
        .btn:hover::before {
            width: 400px;
            height: 400px;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-container {
            text-align: center;
            margin-top: 40px;
        }
        
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: none;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.2);
        }
        
        /* Effects */
        .damage-number {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            color: var(--danger);
            text-shadow: 
                2px 2px 0 #000,
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000;
            animation: damageFloat 1.2s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        
        @keyframes damageFloat {
            0% { 
                opacity: 1;
                transform: translateY(0) scale(0.5);
            }
            30% {
                opacity: 1;
                transform: translateY(-40px) scale(1.3);
            }
            100% { 
                opacity: 0;
                transform: translateY(-80px) scale(0.8);
            }
        }
        
        .critical-hit {
            color: var(--gold) !important;
            font-size: 52px !important;
            animation: criticalFloat 1.5s ease-out forwards;
        }
        
        @keyframes criticalFloat {
            0% { 
                opacity: 1;
                transform: translateY(0) scale(0.5) rotate(-10deg);
            }
            30% {
                opacity: 1;
                transform: translateY(-50px) scale(1.5) rotate(10deg);
            }
            100% { 
                opacity: 0;
                transform: translateY(-100px) scale(0.8) rotate(0deg);
            }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .game-logo {
                font-size: 48px;
            }
            
            .start-button {
                font-size: 20px;
                padding: 15px 40px;
            }
            
            .game-title {
                font-size: 28px;
            }
            
            .character-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .answer-options {
                grid-template-columns: 1fr;
            }
            
            .battle-field {
                flex-direction: column;
                gap: 30px;
            }
            
            .final-stats {
                flex-direction: column;
                gap: 20px;
            }

            .mode-buttons {
                flex-direction: column;
                align-items: center;
            }

            .hud-player {
                flex-direction: column;
                align-items: flex-start;
            }

            .hud-player.p2 {
                align-items: flex-end;
            }
        }
        
        @media (max-width: 480px) {
            .game-logo {
                font-size: 36px;
            }
            
            .character-grid {
                grid-template-columns: 1fr;
            }
            
            .fighter-avatar {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Cover Screen -->
    <div class="cover-screen" id="coverScreen">
        <img src="cover.png" alt="T3 Battle" class="cover-image">
        <div class="cover-overlay"></div>
        <div class="cover-content">
            <div class="game-logo">
                <span class="t3">T3</span>
                <span class="battle">Battle</span>
            </div>
            <button class="start-button" onclick="startGame()">START</button>
        </div>
        <div class="press-start-text">PRESS START</div>
    </div>
    
    <!-- Main Game Container -->
    <div class="game-container" id="gameContainer">
        <div class="container">
            <div class="game-header">
                <div class="game-title">T3 Battle</div>
                <div class="game-subtitle">FIGHTING ARENA</div>
            </div>

            <!-- Mode Selection Screen -->
            <div id="modeScreen" class="screen active">
                <div class="mode-screen">
                    <div class="mode-title">SELECT MODE</div>
                    <div class="mode-buttons">
                        <div class="mode-button" onclick="selectMode('solo')">
                            <div class="mode-icon">ðŸ¤–</div>
                            <div class="mode-name">SOLO</div>
                            <div class="mode-desc">VS AI</div>
                        </div>
                        <div class="mode-button" onclick="selectMode('duo')">
                            <div class="mode-icon">ðŸ‘¥</div>
                            <div class="mode-name">DUO</div>
                            <div class="mode-desc">LOCAL 2P</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Character Selection Screen -->
            <div id="characterScreen" class="screen">
                <button class="btn back-btn" onclick="backToMode()">BACK</button>
                <div class="character-selection-container">
                    <div class="selection-title">CHOOSE YOUR FIGHTER</div>
                    <div id="playerTurnIndicator" class="player-turn-indicator" style="display: none;"></div>
                    <div class="character-showcase">
                        <div class="character-grid" id="characterGrid"></div>
                        <div class="btn-container">
                            <button class="btn" id="startBattleBtn" onclick="startBattle()" disabled>START BATTLE</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Battle Screen -->
            <div id="battleScreen" class="screen">
                <button class="btn back-btn" onclick="backToSelection()">BACK</button>
                <div class="battle-container">
                    <!-- Battle HUD -->
                    <div class="battle-hud">
                        <div class="hud-player p1">
                            <div class="hud-avatar">
                                <img id="hudP1Img" src="" alt="">
                            </div>
                            <div class="hud-info">
                                <div class="hud-name" id="hudP1Name">PLAYER 1</div>
                                <div class="hud-hp-bar">
                                    <div class="hud-hp-ghost" id="hudP1Ghost" style="width: 100%"></div>
                                    <div class="hud-hp-fill" id="hudP1HP" style="width: 100%"></div>
                                    <span class="hud-hp-text" id="hudP1Text">100/100</span>
                                </div>
                            </div>
                        </div>
                        <div class="hud-center">
                            <div class="round-indicator">ROUND 1</div>
                            <div class="hud-timer" id="hudTimer">30</div>
                        </div>
                        <div class="hud-player p2">
                            <div class="hud-avatar">
                                <img id="hudP2Img" src="" alt="">
                            </div>
                            <div class="hud-info p2">
                                <div class="hud-name" id="hudP2Name">PLAYER 2</div>
                                <div class="hud-hp-bar">
                                    <div class="hud-hp-ghost" id="hudP2Ghost" style="width: 100%"></div>
                                    <div class="hud-hp-fill" id="hudP2HP" style="width: 100%"></div>
                                    <span class="hud-hp-text" id="hudP2Text">100/100</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="battle-arena">
                        <div class="battle-field">
                            <div class="fighter player1">
                                <div class="fighter-avatar" id="fighter1Avatar">
                                    <img id="fighter1Img" src="" alt="">
                                </div>
                                <div class="fighter-info">
                                    <div class="fighter-name" id="fighter1Name"></div>
                                    <div class="combo-indicator" id="fighter1Combo"></div>
                                </div>
                            </div>
                            
                            <div class="fighter player2">
                                <div class="fighter-avatar" id="fighter2Avatar">
                                    <img id="fighter2Img" src="" alt="">
                                </div>
                                <div class="fighter-info">
                                    <div class="fighter-name" id="fighter2Name"></div>
                                    <div class="combo-indicator" id="fighter2Combo"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="question-area">
                            <div class="turn-indicator" id="turnIndicator"></div>
                            <div class="question-text" id="questionText"></div>
                            <div class="answer-options" id="answerOptions"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Result Screen -->
            <div id="resultScreen" class="screen">
                <div class="result-screen">
                    <div class="winner-text" id="winnerTitle">VICTORY!</div>
                    <div class="winner-name" id="winnerName"></div>
                    <div class="final-stats">
                        <div class="final-stat">
                            <div class="final-stat-label">CORRECT</div>
                            <div class="final-stat-value" id="correctAnswers">0</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-label">DAMAGE</div>
                            <div class="final-stat-value" id="totalDamage">0</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-label">MAX COMBO</div>
                            <div class="final-stat-value" id="maxCombo">0</div>
                        </div>
                    </div>
                    <div class="btn-container">
                        <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Game State
        let gameState = {
            mode: null, // 'solo' or 'duo'
            currentTurn: 1,
            selectingPlayer: 1, // For duo mode character selection
            player1: null,
            player2: null,
            player1Health: 100,
            player2Health: 100,
            player1Combo: 0,
            player2Combo: 0,
            player1Stats: {
                correct: 0,
                totalDamage: 0,
                maxCombo: 0
            },
            player2Stats: {
                correct: 0,
                totalDamage: 0,
                maxCombo: 0
            },
            questionIndex: 0,
            questionsAnswered: 0,
            timer: null,
            timeLeft: 30
        };
        
        // Character Data
        const characters = [
            {
                id: 'henry',
                name: 'Henry',
                image: 'Henry.gif',
                health: 100,
                attack: 35,
                defense: 20,
                special: 'Speed Type'
            },
            {
                id: 'eason',
                name: 'Eason',
                image: 'Eason.gif',
                health: 90,
                attack: 30,
                defense: 25,
                special: 'Balanced'
            },
            {
                id: 'jason',
                name: 'Jason',
                image: 'Jason.gif',
                health: 120,
                attack: 25,
                defense: 35,
                special: 'Defense Type'
            },
            {
                id: 'joey',
                name: 'Joey',
                image: 'Joey.gif',
                health: 110,
                attack: 28,
                defense: 30,
                special: 'Endurance'
            },
            {
                id: 'quan',
                name: 'Quan',
                image: 'Quan.gif',
                health: 95,
                attack: 32,
                defense: 22,
                special: 'Technical'
            },
            {
                id: 'randy',
                name: 'Randy',
                image: 'Randy.gif',
                health: 85,
                attack: 40,
                defense: 15,
                special: 'Critical'
            },
            {
                id: 'mark',
                name: 'Mark',
                image: 'Mark.gif',
                health: 105,
                attack: 30,
                defense: 28,
                special: 'All-Round'
            },
            {
                id: 'maximus',
                name: 'Maximus',
                image: 'Maximus.gif',
                health: 115,
                attack: 27,
                defense: 32,
                special: 'Tank'
            },
            {
                id: 'bruce',
                name: 'Bruce',
                image: 'Bruce.gif',
                health: 100,
                attack: 33,
                defense: 25,
                special: 'Fighter'
            }
        ];
        
        // Question Bank (loaded from external JSON)
        let QUESTION_BANK = [];
        let currentGameQuestions = [];
        let currentQuestionIndex = 0;
        const QUESTIONS_PER_GAME = 20;

        // Load question bank from external JSON
        async function loadQuestionBank() {
            try {
                const response = await fetch('./questionBank_choice_final.json', { cache: 'no-store' });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Validate the data
                if (!Array.isArray(data)) {
                    throw new Error('Question bank is not an array');
                }
                
                if (data.length === 0) {
                    throw new Error('Question bank is empty');
                }
                
                // Validate question format
                const validQuestions = data.filter(q => {
                    if (!q.question || !q.type) return false;
                    if (q.type === 'choice' && (!q.options || !Array.isArray(q.options) || q.options.length < 2 || typeof q.correct !== 'number')) {
                        return false;
                    }
                    if (q.type === 'fill' && !q.answer) return false;
                    return true;
                });
                
                if (validQuestions.length === 0) {
                    throw new Error('No valid questions found in question bank');
                }
                
                console.log(`Loaded ${validQuestions.length} questions from question bank`);
                return validQuestions;
                
            } catch (error) {
                console.error('Error loading question bank:', error);
                throw error;
            }
        }

        // Show error message if question bank fails to load
        function showLoadError(message) {
            const errorOverlay = document.createElement('div');
            errorOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                font-family: 'Press Start 2P', cursive;
                color: #ff0044;
                text-align: center;
                padding: 20px;
            `;
            
            errorOverlay.innerHTML = `
                <div style="font-size: 32px; margin-bottom: 30px;">ERROR!</div>
                <div style="font-size: 16px; margin-bottom: 30px; max-width: 600px; line-height: 1.5;">
                    FAILED TO LOAD QUESTION BANK<br><br>
                    ${message}<br><br>
                    CHECK FILE PATH OR GITHUB PAGES
                </div>
                <button onclick="location.reload()" style="
                    padding: 15px 30px;
                    font-family: 'Press Start 2P', cursive;
                    font-size: 14px;
                    background: linear-gradient(135deg, #ffcc00, #ff0044);
                    border: none;
                    border-radius: 10px;
                    color: white;
                    cursor: pointer;
                ">RELOAD</button>
            `;
            
            document.body.appendChild(errorOverlay);
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Prepare questions for a game session
        function prepareGameQuestions() {
            if (QUESTION_BANK.length === 0) {
                console.error('Question bank is empty!');
                return;
            }
            
            // Filter questions based on type (only choice questions)
            let availableQuestions = QUESTION_BANK.filter(q => q.type === 'choice');
            
            // Apply difficulty filtering if in solo mode
            if (gameState.mode === 'solo') {
                const difficultyLevel = gameState.difficulty;
                let targetDifficulties = [];
                
                if (difficultyLevel === 'easy') {
                    targetDifficulties = [1];
                } else if (difficultyLevel === 'normal') {
                    targetDifficulties = [1, 2];
                } else if (difficultyLevel === 'hard') {
                    targetDifficulties = [2, 3];
                }
                
                // Get questions of target difficulty
                let filteredQuestions = availableQuestions.filter(q => 
                    q.difficulty && targetDifficulties.includes(q.difficulty)
                );
                
                // If not enough questions, expand the difficulty range
                if (filteredQuestions.length < QUESTIONS_PER_GAME) {
                    console.log(`Only ${filteredQuestions.length} questions for difficulty ${difficultyLevel}, expanding selection...`);
                    
                    if (difficultyLevel === 'easy') {
                        // Add medium questions
                        const mediumQuestions = availableQuestions.filter(q => q.difficulty === 2);
                        filteredQuestions = [...filteredQuestions, ...mediumQuestions];
                    } else if (difficultyLevel === 'normal') {
                        // Add hard questions
                        const hardQuestions = availableQuestions.filter(q => q.difficulty === 3);
                        filteredQuestions = [...filteredQuestions, ...hardQuestions];
                    } else if (difficultyLevel === 'hard') {
                        // Add normal questions
                        const normalQuestions = availableQuestions.filter(q => q.difficulty === 1);
                        filteredQuestions = [...filteredQuestions, ...normalQuestions];
                    }
                }
                
                // If still not enough, use all available questions
                if (filteredQuestions.length < QUESTIONS_PER_GAME) {
                    console.log(`Still only ${filteredQuestions.length} questions, using all available questions`);
                    filteredQuestions = availableQuestions;
                }
                
                availableQuestions = filteredQuestions;
            }
            
            // Shuffle all available questions
            const shuffled = shuffleArray(availableQuestions);
            
            // Take the required number of questions or all if less available
            currentGameQuestions = shuffled.slice(0, Math.min(QUESTIONS_PER_GAME, shuffled.length));
            currentQuestionIndex = 0;
            
            console.log(`Prepared ${currentGameQuestions.length} questions for this game`);
        }

        // Get next question from the prepared list
        function getQuestion() {
            if (currentGameQuestions.length === 0) {
                console.error('No questions prepared for this game!');
                return null;
            }
            
            if (currentQuestionIndex >= currentGameQuestions.length) {
                // If we've used all questions, shuffle and restart (shouldn't happen with 20 questions limit)
                currentGameQuestions = shuffleArray(currentGameQuestions);
                currentQuestionIndex = 0;
            }
            
            const question = currentGameQuestions[currentQuestionIndex];
            currentQuestionIndex++;
            
            return question;
        }
        
        // Initialize
        async function init() {
            // Setup keyboard listeners for buzz mode
            document.addEventListener('keydown', handleBuzzKey);
        }

        // Buzz Mode Handler
        function handleBuzzKey(e) {
            if (!gameState.buzzMode || gameState.buzzWinner !== null) return;
            
            const key = e.key.toLowerCase();
            if (key === 'a') {
                gameState.buzzWinner = 1;
                lockOutBuzz();
            } else if (key === 'l') {
                gameState.buzzWinner = 2;
                lockOutBuzz();
            }
        }

        function lockOutBuzz() {
            if (gameState.buzzWinner === 1) {
                gameState.currentTurn = 1;
                document.getElementById('turnIndicator').textContent = 'PLAYER 1 BUZZED!';
            } else {
                gameState.currentTurn = 2;
                document.getElementById('turnIndicator').textContent = 'PLAYER 2 BUZZED!';
            }
            
            // Lock out the other player's answer buttons
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.classList.remove('locked');
            });
        }
        
        // Start Game from Cover
        async function startGame() {
            try {
                // Load question bank first
                QUESTION_BANK = await loadQuestionBank();
                
                // If successful, proceed with game
                document.getElementById('coverScreen').classList.add('hidden');
                setTimeout(() => {
                    document.getElementById('coverScreen').style.display = 'none';
                    document.getElementById('gameContainer').classList.add('active');
                    showScreen('modeScreen');
                }, 500);
            } catch (error) {
                showLoadError(error.message);
            }
        }

        // Mode Selection
        function selectMode(mode) {
            gameState.mode = mode;
            gameState.selectingPlayer = 1;
            
            if (mode === 'solo') {
                document.getElementById('difficultySelection').style.display = 'block';
                document.getElementById('duoOptions').style.display = 'none';
            } else {
                document.getElementById('difficultySelection').style.display = 'none';
                document.getElementById('duoOptions').style.display = 'block';
            }
            
            setTimeout(() => {
                showScreen('characterScreen');
                renderCharacters();
                
                if (mode === 'duo') {
                    document.getElementById('playerTurnIndicator').style.display = 'block';
                    document.getElementById('playerTurnIndicator').className = 'player-turn-indicator player1';
                    document.getElementById('playerTurnIndicator').textContent = 'PLAYER 1 SELECT';
                } else {
                    document.getElementById('playerTurnIndicator').style.display = 'none';
                }
            }, 500);
        }

        // Difficulty Selection
        function selectDifficulty(level) {
            gameState.difficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        // Buzz Mode Toggle
        function toggleBuzz() {
            gameState.buzzMode = !gameState.buzzMode;
            const toggle = document.getElementById('buzzToggle');
            const status = document.getElementById('buzzStatus');
            
            if (gameState.buzzMode) {
                toggle.classList.add('active');
                status.textContent = 'ON';
            } else {
                toggle.classList.remove('active');
                status.textContent = 'OFF';
            }
        }

        function backToMode() {
            resetGameState();
            showScreen('modeScreen');
        }
        
        // Screen Management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }
        
        function backToSelection() {
            resetGameState();
            showScreen('characterScreen');
            renderCharacters();
        }
        
        // Character Selection
        function renderCharacters() {
            const characterGrid = document.getElementById('characterGrid');
            characterGrid.innerHTML = '';
            
            characters.forEach(char => {
                const card = createCharacterCard(char);
                characterGrid.appendChild(card);
            });
        }
        
        function createCharacterCard(character) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.onclick = () => selectCharacter(character);
            card.dataset.characterId = character.id;
            
            card.innerHTML = `
                <div class="character-avatar">
                    <img src="${character.image}" alt="${character.name}">
                </div>
                <div class="character-name">${character.name}</div>
                <div class="character-stats">
                    <div class="stat">
                        <span class="stat-name">HP</span>
                        <div class="stat-bar">
                            <div class="stat-fill health" style="width: ${character.health}%"></div>
                        </div>
                    </div>
                    <div class="stat">
                        <span class="stat-name">ATK</span>
                        <div class="stat-bar">
                            <div class="stat-fill attack" style="width: ${character.attack * 2}%"></div>
                        </div>
                    </div>
                    <div class="stat">
                        <span class="stat-name">DEF</span>
                        <div class="stat-bar">
                            <div class="stat-fill defense" style="width: ${character.defense * 2}%"></div>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function selectCharacter(character) {
            if (gameState.mode === 'solo') {
                // Solo mode: Select P1, auto-assign P2
                document.querySelectorAll('.character-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                event.currentTarget.classList.add('selected');
                gameState.player1 = character;
                
                // Auto select AI opponent
                setTimeout(() => {
                    const availableChars = characters.filter(c => c.id !== character.id);
                    const randomChar = availableChars[Math.floor(Math.random() * availableChars.length)];
                    gameState.player2 = randomChar;
                    
                    // Enable start button
                    document.getElementById('startBattleBtn').disabled = false;
                }, 500);
            } else if (gameState.mode === 'duo') {
                // Duo mode: Sequential selection
                if (gameState.selectingPlayer === 1) {
                    // Player 1 selecting
                    document.querySelectorAll('.character-card').forEach(card => {
                        card.classList.remove('selected');
                    });
                    
                    event.currentTarget.classList.add('selected');
                    gameState.player1 = character;
                    gameState.selectingPlayer = 2;
                    
                    // Update indicator
                    document.getElementById('playerTurnIndicator').className = 'player-turn-indicator player2';
                    document.getElementById('playerTurnIndicator').textContent = 'PLAYER 2 SELECT';
                    
                    // Disable selected character
                    event.currentTarget.classList.add('disabled');
                } else if (gameState.selectingPlayer === 2) {
                    // Player 2 selecting
                    if (character.id === gameState.player1.id) return; // Can't select same character
                    
                    event.currentTarget.classList.add('selected');
                    gameState.player2 = character;
                    
                    // Enable start button
                    document.getElementById('startBattleBtn').disabled = false;
                    document.getElementById('playerTurnIndicator').style.display = 'none';
                }
            }
        }
        
        // Battle System
        function startBattle() {
            if (!gameState.player1 || !gameState.player2) return;
            
            showScreen('battleScreen');
            initializeBattle();
            nextQuestion();
        }
        
        function initializeBattle() {
            // Set HUD info
            document.getElementById('hudP1Name').textContent = gameState.player1.name;
            document.getElementById('hudP1Img').src = gameState.player1.image;
            document.getElementById('hudP2Name').textContent = gameState.mode === 'solo' ? `AI ${gameState.player2.name}` : gameState.player2.name;
            document.getElementById('hudP2Img').src = gameState.player2.image;
            
            // Set fighter info
            document.getElementById('fighter1Name').textContent = gameState.player1.name;
            document.getElementById('fighter1Img').src = gameState.player1.image;
            document.getElementById('fighter2Name').textContent = gameState.mode === 'solo' ? `AI ${gameState.player2.name}` : gameState.player2.name;
            document.getElementById('fighter2Img').src = gameState.player2.image;
            
            // Initialize health and energy
            gameState.player1Health = gameState.player1.health;
            gameState.player1MaxHealth = gameState.player1.health;
            gameState.player2Health = gameState.player2.health;
            gameState.player2MaxHealth = gameState.player2.health;
            gameState.player1Energy = 0;
            gameState.player2Energy = 0;
            
            updateHealthBar(1);
            updateHealthBar(2);
            updateEnergyBar(1);
            updateEnergyBar(2);
            
            // Reset combos and questions
            gameState.player1Combo = 0;
            gameState.player2Combo = 0;
            gameState.questionsAnswered = 0;
            updateComboDisplay(1);
            updateComboDisplay(2);
            
            // Prepare questions for this game
            prepareGameQuestions();
            
            // Show buzz indicator if in buzz mode
            if (gameState.buzzMode && gameState.mode === 'duo') {
                document.getElementById('buzzIndicator').style.display = 'block';
            }
        }
        
        
        function selectStance(stance) {
            const currentPlayer = gameState.buzzWinner || gameState.currentTurn;
            
            if (currentPlayer === 1) {
                gameState.player1Stance = stance;
            } else {
                gameState.player2Stance = stance;
            }
            
            // Highlight selected stance
            document.querySelectorAll('.stance-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
            
            // Hide stance selection and show question
            setTimeout(() => {
                document.getElementById('stanceSelection').style.display = 'none';
                showQuestion();
            }, 300);
        }
        
        function nextQuestion() {
            // Check if we've answered enough questions
            if (gameState.questionsAnswered >= QUESTIONS_PER_GAME) {
                endGame();
                return;
            }
            
            if (gameState.player1Health <= 0 || gameState.player2Health <= 0) {
                endGame();
                return;
            }
            
            // Reset buzz winner for new question
            gameState.buzzWinner = null;
            
            // Show stance selection first
            document.getElementById('stanceSelection').style.display = 'block';
            document.getElementById('questionText').textContent = '';
            document.getElementById('answerOptions').innerHTML = '';
            
            const currentPlayer = gameState.buzzMode ? null : gameState.currentTurn;
            const turnIndicator = document.getElementById('turnIndicator');
            
            if (gameState.buzzMode && gameState.mode === 'duo') {
                turnIndicator.textContent = 'WAITING FOR BUZZ...';
            } else if (gameState.mode === 'solo') {
                turnIndicator.textContent = currentPlayer === 1 ? 'PLAYER TURN' : 'AI TURN';
                
                // AI auto-selects stance
                if (currentPlayer === 2) {
                    const stances = ['attack', 'defend', 'dodge', 'gamble'];
                    gameState.player2Stance = stances[Math.floor(Math.random() * stances.length)];
                    setTimeout(() => {
                        document.getElementById('stanceSelection').style.display = 'none';
                        showQuestion();
                    }, 1000);
                }
            } else {
                turnIndicator.textContent = `PLAYER ${currentPlayer} TURN`;
            }
        }

        function showQuestion() {
            const question = getQuestion();
            if (!question) {
                console.error('No question available!');
                return;
            }
            
            document.getElementById('questionText').textContent = question.question;
            
            const answerContainer = document.getElementById('answerOptions');
            answerContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = option;
                btn.onclick = () => checkAnswer(index, question.correct);
                
                // Handle button states based on mode
                if (gameState.buzzMode && gameState.buzzWinner === null) {
                    // In buzz mode, enable all buttons but they won't work until someone buzzes
                    btn.onclick = () => {
                        if (gameState.buzzWinner !== null) {
                            checkAnswer(index, question.correct);
                        }
                    };
                } else if (gameState.mode === 'solo' && gameState.currentTurn === 2) {
                    btn.disabled = true;
                }
                
                answerContainer.appendChild(btn);
            });
            
            startTimer();
            
            // AI auto answer in solo mode
            if (gameState.mode === 'solo' && gameState.currentTurn === 2) {
                const diffConfig = gameConfig.difficulty[gameState.difficulty];
                const delay = diffConfig.reactionDelay.min + 
                             Math.random() * (diffConfig.reactionDelay.max - diffConfig.reactionDelay.min);
                
                setTimeout(() => {
                    const aiAnswer = Math.random() < diffConfig.accuracy ? 
                                   question.correct : 
                                   Math.floor(Math.random() * 4);
                    checkAnswer(aiAnswer, question.correct);
                }, delay);
            }
        }
        
        function startTimer() {
            gameState.timeLeft = 30;
            const timerElement = document.getElementById('hudTimer');
            
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            timerElement.classList.remove('warning');
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                timerElement.textContent = gameState.timeLeft;
                
                if (gameState.timeLeft <= 10) {
                    timerElement.classList.add('warning');
                }
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    if (gameState.mode === 'solo' && gameState.currentTurn === 1) {
                        checkAnswer(-1, -1);
                    } else if (gameState.mode === 'duo') {
                        checkAnswer(-1, -1);
                    }
                }
            }, 1000);
        }
        
        function checkAnswer(selected, correct) {
            clearInterval(gameState.timer);
            
            // Increment questions answered
            gameState.questionsAnswered++;
            
            // Show correct/wrong answers
            document.querySelectorAll('.answer-btn').forEach((btn, index) => {
                btn.disabled = true;
                if (index === correct) {
                    btn.classList.add('correct');
                } else if (index === selected && selected !== correct) {
                    btn.classList.add('wrong');
                }
            });
            
            const currentPlayer = gameState.buzzWinner || gameState.currentTurn;
            const isCorrect = selected === correct;
            const attackerStance = currentPlayer === 1 ? gameState.player1Stance : gameState.player2Stance;
            const defenderStance = currentPlayer === 1 ? gameState.player2Stance : gameState.player1Stance;
            const stanceConfig = gameConfig.stances[attackerStance];
            
            if (isCorrect) {
                // Handle correct answer
                if (currentPlayer === 1) {
                    gameState.player1Combo++;
                    gameState.player1Stats.correct++;
                    gameState.player1Energy = Math.min(100, gameState.player1Energy + gameConfig.energy.correctBonus);
                    
                    if (gameState.player1Combo > gameState.player1Stats.maxCombo) {
                        gameState.player1Stats.maxCombo = gameState.player1Combo;
                    }
                } else {
                    gameState.player2Combo++;
                    gameState.player2Stats.correct++;
                    gameState.player2Energy = Math.min(100, gameState.player2Energy + gameConfig.energy.correctBonus);
                    
                    if (gameState.player2Combo > gameState.player2Stats.maxCombo) {
                        gameState.player2Stats.maxCombo = gameState.player2Combo;
                    }
                }
                
                // Calculate damage
                const attacker = currentPlayer === 1 ? gameState.player1 : gameState.player2;
                const defender = currentPlayer === 1 ? gameState.player2 : gameState.player1;
                const combo = currentPlayer === 1 ? gameState.player1Combo : gameState.player2Combo;
                const energy = currentPlayer === 1 ? gameState.player1Energy : gameState.player2Energy;
                
                let damage = attacker.attack - (defender.defense * 0.3);
                
                // Apply attacker stance multiplier
                damage *= stanceConfig.damageMultiplier;
                
                // Apply defender's stance defense
                if (defenderStance === 'defend') {
                    damage *= (1 - gameConfig.stances.defend.defenseMultiplier); // Reduce damage by 70%
                } else if (defenderStance === 'dodge' && Math.random() < gameConfig.stances.dodge.dodgeChance) {
                    damage = 0; // Complete dodge
                    console.log('Attack dodged!');
                }
                
                // Combo bonus
                if (combo >= 3) {
                    damage *= 1.5;
                }
                if (combo >= 5) {
                    damage *= 1.8;
                }
                
                // Special move if energy is full
                let isSpecial = false;
                if (energy >= 100) {
                    damage *= gameConfig.energy.specialMultiplier;
                    isSpecial = true;
                    
                    // Reset energy after special
                    if (currentPlayer === 1) {
                        gameState.player1Energy = 0;
                    } else {
                        gameState.player2Energy = 0;
                    }
                }
                
                damage = Math.round(Math.max(damage, damage > 0 ? 10 : 0));
                
                // Apply damage
                if (damage > 0) {
                    if (currentPlayer === 1) {
                        gameState.player2Health -= damage;
                        gameState.player1Stats.totalDamage += damage;
                        showDamageEffect(2, damage, combo >= 3);
                        
                        if (isSpecial) {
                            performSpecialAttack(1);
                        } else {
                            performAttackAnimation(1);
                        }
                    } else {
                        gameState.player1Health -= damage;
                        gameState.player2Stats.totalDamage += damage;
                        showDamageEffect(1, damage, combo >= 3);
                        
                        if (isSpecial) {
                            performSpecialAttack(2);
                        } else {
                            performAttackAnimation(2);
                        }
                    }
                }
                
                updateHealthBar(currentPlayer === 1 ? 2 : 1);
                updateEnergyBar(currentPlayer);
                updateComboDisplay(currentPlayer);
            } else {
                // Handle wrong answer
                // Reset combo and potentially energy
                if (currentPlayer === 1) {
                    gameState.player1Combo = 0;
                    if (gameState.player1Energy >= 100) {
                        gameState.player1Energy = 0; // Risk of full energy
                    }
                    
                    // Apply penalty for wrong answer (only for gamble stance)
                    if (attackerStance === 'gamble') {
                        const penalty = Math.round(20 * stanceConfig.defenseMultiplier);
                        gameState.player1Health -= penalty;
                        showDamageEffect(1, penalty, false);
                        updateHealthBar(1);
                    }
                } else {
                    gameState.player2Combo = 0;
                    if (gameState.player2Energy >= 100) {
                        gameState.player2Energy = 0; // Risk of full energy
                    }
                    
                    // Apply penalty for wrong answer (only for gamble stance)
                    if (attackerStance === 'gamble') {
                        const penalty = Math.round(20 * stanceConfig.defenseMultiplier);
                        gameState.player2Health -= penalty;
                        showDamageEffect(2, penalty, false);
                        updateHealthBar(2);
                    }
                }
                
                updateEnergyBar(currentPlayer);
                updateComboDisplay(currentPlayer);
            }
            
            // Switch turns (unless in buzz mode)
            setTimeout(() => {
                if (!gameState.buzzMode || gameState.mode === 'solo') {
                    gameState.currentTurn = gameState.currentTurn === 1 ? 2 : 1;
                }
                nextQuestion();
            }, 2000);
        }
        
        function updateHealthBar(player) {
            const health = player === 1 ? gameState.player1Health : gameState.player2Health;
            const maxHealth = player === 1 ? gameState.player1MaxHealth : gameState.player2MaxHealth;
            const percentage = Math.max(0, (health / maxHealth) * 100);
            
            // Update HUD bars
            const hudHP = document.getElementById(`hudP${player}HP`);
            const hudGhost = document.getElementById(`hudP${player}Ghost`);
            const hudText = document.getElementById(`hudP${player}Text`);
            
            hudHP.style.width = `${percentage}%`;
            hudText.textContent = `${Math.max(0, Math.round(health))}/${maxHealth}`;
            
            // Ghost bar effect (delayed)
            setTimeout(() => {
                hudGhost.style.width = `${percentage}%`;
            }, 100);
            
            // Change color based on health
            if (percentage <= 20) {
                hudHP.style.background = 'linear-gradient(90deg, #ff3366, #cc0000)';
            } else if (percentage <= 50) {
                hudHP.style.background = 'linear-gradient(90deg, #ffcc00, #ff9900)';
            }
        }

        function updateEnergyBar(player) {
            const energy = player === 1 ? gameState.player1Energy : gameState.player2Energy;
            const percentage = (energy / gameConfig.energy.maxEnergy) * 100;
            
            const energyBar = document.getElementById(`hudP${player}Energy`);
            const energyText = document.getElementById(`hudP${player}EnergyText`);
            
            energyBar.style.width = `${percentage}%`;
            energyText.textContent = energy;
            
            if (energy >= 100) {
                energyBar.classList.add('full');
            } else {
                energyBar.classList.remove('full');
            }
        }
        
        function updateComboDisplay(player) {
            const combo = player === 1 ? gameState.player1Combo : gameState.player2Combo;
            const comboElement = document.getElementById(`fighter${player}Combo`);
            
            if (combo > 0) {
                comboElement.textContent = `ðŸ”¥ COMBO x${combo}`;
                comboElement.classList.add('active');
                
                if (combo >= 5) {
                    comboElement.textContent = `ðŸ”¥ðŸ”¥ SUPER COMBO x${combo}`;
                }
            } else {
                comboElement.textContent = '';
                comboElement.classList.remove('active');
            }
        }
        
        function performAttackAnimation(attacker) {
            const avatar = document.getElementById(`fighter${attacker}Avatar`);
            const defender = attacker === 1 ? 2 : 1;
            const defenderAvatar = document.getElementById(`fighter${defender}Avatar`);
            
            avatar.classList.add('attacking');
            setTimeout(() => {
                avatar.classList.remove('attacking');
                defenderAvatar.classList.add('damaged');
                setTimeout(() => {
                    defenderAvatar.classList.remove('damaged');
                }, 500);
            }, 250);
        }

        function performSpecialAttack(attacker) {
            const avatar = document.getElementById(`fighter${attacker}Avatar`);
            const defender = attacker === 1 ? 2 : 1;
            const defenderAvatar = document.getElementById(`fighter${defender}Avatar`);
            
            // Add screen shake
            document.getElementById('gameContainer').classList.add('screen-shake');
            
            // Show special effect text
            const specialText = document.createElement('div');
            specialText.className = 'special-effect';
            specialText.textContent = 'SPECIAL!';
            document.querySelector('.battle-arena').appendChild(specialText);
            
            avatar.classList.add('special');
            setTimeout(() => {
                avatar.classList.remove('special');
                defenderAvatar.classList.add('damaged');
                
                setTimeout(() => {
                    defenderAvatar.classList.remove('damaged');
                    document.getElementById('gameContainer').classList.remove('screen-shake');
                    specialText.remove();
                }, 1000);
            }, 500);
        }
        
        function showDamageEffect(target, damage, isCritical) {
            const fighter = document.querySelector(`.fighter.player${target}`);
            const damageNumber = document.createElement('div');
            damageNumber.className = 'damage-number';
            if (isCritical) {
                damageNumber.classList.add('critical-hit');
                damageNumber.textContent = `CRITICAL! -${damage}`;
            } else {
                damageNumber.textContent = `-${damage}`;
            }
            
            damageNumber.style.left = '50%';
            damageNumber.style.top = '20%';
            fighter.appendChild(damageNumber);
            
            setTimeout(() => {
                damageNumber.remove();
            }, 1200);
        }
        
        function endGame() {
            const winner = gameState.player1Health > 0 ? 1 : 2;
            const winnerChar = winner === 1 ? gameState.player1 : gameState.player2;
            const winnerStats = winner === 1 ? gameState.player1Stats : gameState.player2Stats;
            
            if (gameState.mode === 'solo') {
                document.getElementById('winnerTitle').textContent = winner === 1 ? 'VICTORY!' : 'DEFEAT...';
                document.getElementById('winnerName').textContent = winner === 1 ? winnerChar.name : `AI ${winnerChar.name} WINS`;
                document.getElementById('correctAnswers').textContent = gameState.player1Stats.correct;
                document.getElementById('totalDamage').textContent = gameState.player1Stats.totalDamage;
                document.getElementById('maxCombo').textContent = gameState.player1Stats.maxCombo;
            } else {
                document.getElementById('winnerTitle').textContent = 'VICTORY!';
                document.getElementById('winnerName').textContent = `PLAYER ${winner} - ${winnerChar.name} WINS`;
                document.getElementById('correctAnswers').textContent = winnerStats.correct;
                document.getElementById('totalDamage').textContent = winnerStats.totalDamage;
                document.getElementById('maxCombo').textContent = winnerStats.maxCombo;
            }
            
            if (winner === 2 && gameState.mode === 'solo') {
                document.getElementById('winnerTitle').style.color = 'var(--danger)';
            }
            
            showScreen('resultScreen');
        }
        
        function resetGameState() {
            gameState = {
                mode: null,
                difficulty: 'normal',
                buzzMode: false,
                currentTurn: 1,
                selectingPlayer: 1,
                player1: null,
                player2: null,
                player1Health: 100,
                player2Health: 100,
                player1Energy: 0,
                player2Energy: 0,
                player1Combo: 0,
                player2Combo: 0,
                player1Stance: 'attack',
                player2Stance: 'attack',
                buzzWinner: null,
                player1Stats: {
                    correct: 0,
                    totalDamage: 0,
                    maxCombo: 0
                },
                player2Stats: {
                    correct: 0,
                    totalDamage: 0,
                    maxCombo: 0
                },
                questionIndex: 0,
                timer: null,
                timeLeft: 30
            };
            
            document.getElementById('startBattleBtn').disabled = true;
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected', 'disabled');
            });
        }
        
        function resetGame() {
            resetGameState();
            showScreen('modeScreen');
        }
        
        // Initialize
        init();
    </script>
</body>
</html> damage
                if (currentPlayer === 1) {
                    gameState.player2Health -= damage;
                    gameState.player1Stats.totalDamage += damage;
                    showDamageEffect(2, damage, combo >= 3);
                    performAttackAnimation(1);
                } else {
                    gameState.player1Health -= damage;
                    gameState.player2Stats.totalDamage += damage;
                    showDamageEffect(1, damage, combo >= 3);
                    performAttackAnimation(2);
                }
                
                updateHealthBar(currentPlayer === 1 ? 2 : 1);
                updateComboDisplay(currentPlayer);
            } else {
                // Reset combo on wrong answer
                if (currentPlayer === 1) {
                    gameState.player1Combo = 0;
                } else {
                    gameState.player2Combo = 0;
                }
                updateComboDisplay(currentPlayer);
            }
            
            // Switch turns
            setTimeout(() => {
                gameState.currentTurn = gameState.currentTurn === 1 ? 2 : 1;
                nextQuestion();
            }, 2000);
        }
        
        function updateHealthBar(player) {
            const health = player === 1 ? gameState.player1Health : gameState.player2Health;
            const maxHealth = player === 1 ? gameState.player1MaxHealth : gameState.player2MaxHealth;
            const percentage = Math.max(0, (health / maxHealth) * 100);
            
            // Update HUD bars
            const hudHP = document.getElementById(`hudP${player}HP`);
            const hudGhost = document.getElementById(`hudP${player}Ghost`);
            const hudText = document.getElementById(`hudP${player}Text`);
            
            hudHP.style.width = `${percentage}%`;
            hudText.textContent = `${Math.max(0, Math.round(health))}/${maxHealth}`;
            
            // Ghost bar effect (delayed)
            setTimeout(() => {
                hudGhost.style.width = `${percentage}%`;
            }, 100);
            
            // Change color based on health
            if (percentage <= 20) {
                hudHP.style.background = 'linear-gradient(90deg, #ff3366, #cc0000)';
            } else if (percentage <= 50) {
                hudHP.style.background = 'linear-gradient(90deg, #ffcc00, #ff9900)';
            }
        }

        function updateEnergyBar(player) {
            const energy = player === 1 ? gameState.player1Energy : gameState.player2Energy;
            const percentage = (energy / gameConfig.energy.maxEnergy) * 100;
            
            const energyBar = document.getElementById(`hudP${player}Energy`);
            const energyText = document.getElementById(`hudP${player}EnergyText`);
            
            energyBar.style.width = `${percentage}%`;
            energyText.textContent = energy;
            
            if (energy >= 100) {
                energyBar.classList.add('full');
            } else {
                energyBar.classList.remove('full');
            }
        }
        
        function updateComboDisplay(player) {
            const combo = player === 1 ? gameState.player1Combo : gameState.player2Combo;
            const comboElement = document.getElementById(`fighter${player}Combo`);
            
            if (combo > 0) {
                comboElement.textContent = `ðŸ”¥ COMBO x${combo}`;
                comboElement.classList.add('active');
                
                if (combo >= 5) {
                    comboElement.textContent = `ðŸ”¥ðŸ”¥ SUPER COMBO x${combo}`;
                }
            } else {
                comboElement.textContent = '';
                comboElement.classList.remove('active');
            }
        }
        
        function performAttackAnimation(attacker) {
            const avatar = document.getElementById(`fighter${attacker}Avatar`);
            const defender = attacker === 1 ? 2 : 1;
            const defenderAvatar = document.getElementById(`fighter${defender}Avatar`);
            
            avatar.classList.add('attacking');
            setTimeout(() => {
                avatar.classList.remove('attacking');
                defenderAvatar.classList.add('damaged');
                setTimeout(() => {
                    defenderAvatar.classList.remove('damaged');
                }, 500);
            }, 250);
        }
        
        function showDamageEffect(target, damage, isCritical) {
            const fighter = document.querySelector(`.fighter.player${target}`);
            const damageNumber = document.createElement('div');
            damageNumber.className = 'damage-number';
            if (isCritical) {
                damageNumber.classList.add('critical-hit');
                damageNumber.textContent = `CRITICAL! -${damage}`;
            } else {
                damageNumber.textContent = `-${damage}`;
            }
            
            damageNumber.style.left = '50%';
            damageNumber.style.top = '20%';
            fighter.appendChild(damageNumber);
            
            setTimeout(() => {
                damageNumber.remove();
            }, 1200);
        }
        
        function endGame() {
            const winner = gameState.player1Health > 0 ? 1 : 2;
            const winnerChar = winner === 1 ? gameState.player1 : gameState.player2;
            const winnerStats = winner === 1 ? gameState.player1Stats : gameState.player2Stats;
            
            if (gameState.mode === 'solo') {
                document.getElementById('winnerTitle').textContent = winner === 1 ? 'VICTORY!' : 'DEFEAT...';
                document.getElementById('winnerName').textContent = winner === 1 ? winnerChar.name : `AI ${winnerChar.name} WINS`;
                document.getElementById('correctAnswers').textContent = gameState.player1Stats.correct;
                document.getElementById('totalDamage').textContent = gameState.player1Stats.totalDamage;
                document.getElementById('maxCombo').textContent = gameState.player1Stats.maxCombo;
            } else {
                document.getElementById('winnerTitle').textContent = 'VICTORY!';
                document.getElementById('winnerName').textContent = `PLAYER ${winner} - ${winnerChar.name} WINS`;
                document.getElementById('correctAnswers').textContent = winnerStats.correct;
                document.getElementById('totalDamage').textContent = winnerStats.totalDamage;
                document.getElementById('maxCombo').textContent = winnerStats.maxCombo;
            }
            
            if (winner === 2 && gameState.mode === 'solo') {
                document.getElementById('winnerTitle').style.color = 'var(--danger)';
            }
            
            showScreen('resultScreen');
        }
        
        function resetGameState() {
            gameState = {
                mode: null,
                difficulty: 'normal',
                buzzMode: false,
                currentTurn: 1,
                selectingPlayer: 1,
                player1: null,
                player2: null,
                player1Health: 100,
                player2Health: 100,
                player1Energy: 0,
                player2Energy: 0,
                player1Combo: 0,
                player2Combo: 0,
                player1Stance: 'attack',
                player2Stance: 'attack',
                buzzWinner: null,
                player1Stats: {
                    correct: 0,
                    totalDamage: 0,
                    maxCombo: 0
                },
                player2Stats: {
                    correct: 0,
                    totalDamage: 0,
                    maxCombo: 0
                },
                questionIndex: 0,
                questionsAnswered: 0,
                timer: null,
                timeLeft: 30
            };
            
            // Reset question list
            currentGameQuestions = [];
            currentQuestionIndex = 0;
            
            document.getElementById('startBattleBtn').disabled = true;
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected', 'disabled');
            });
        }
        
        function resetGame() {
            resetGameState();
            showScreen('modeScreen');
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
